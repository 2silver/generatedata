"use strict";
var __assign = (this && this.__assign) || function () {
    __assign = Object.assign || function(t) {
        for (var s, i = 1, n = arguments.length; i < n; i++) {
            s = arguments[i];
            for (var p in s) if (Object.prototype.hasOwnProperty.call(s, p))
                t[p] = s[p];
        }
        return t;
    };
    return __assign.apply(this, arguments);
};
var __importDefault = (this && this.__importDefault) || function (mod) {
    return (mod && mod.__esModule) ? mod : { "default": mod };
};
var estree_walker_1 = require("estree-walker");
var magic_string_1 = __importDefault(require("magic-string"));
var astring_1 = require("astring");
var options_1 = require("./options");
module.exports = function stripExports(options) {
    if (options === void 0) { options = {}; }
    options = __assign(__assign({}, options_1.defaultStripExportsOptions), options);
    return {
        name: 'strip-exports',
        transform: function (code, id) {
            if (!this.getModuleInfo(id).isEntry) {
                return;
            }
            var ast = this.parse(code, { ranges: true });
            var magicString = new magic_string_1["default"](code);
            var removed = false;
            estree_walker_1.walk(ast, {
                enter: function (baseNode) {
                    var node = baseNode;
                    if (node && node.range) {
                        var _a = node.range, start = _a[0], end = _a[1];
                        if (options.sourceMap) {
                            magicString.addSourcemapLocation(start);
                            magicString.addSourcemapLocation(end);
                        }
                        switch (node.type) {
                            case 'ExportAllDeclaration':
                                magicString.remove(start, end);
                                removed = true;
                                this.skip();
                                break;
                            case 'ExportNamedDeclaration':
                            case 'ExportDefaultDeclaration':
                                if (node.declaration &&
                                    node.declaration.type !== 'Literal' &&
                                    node.declaration.type !== 'Identifier') {
                                    magicString.overwrite(start, end, astring_1.generate(node.declaration));
                                    removed = true;
                                    this.skip();
                                }
                                else {
                                    magicString.remove(start, end);
                                    removed = true;
                                    this.skip();
                                }
                                break;
                        }
                    }
                }
            });
            if (!removed) {
                return null;
            }
            var map = options.sourceMap ? magicString.generateMap() : undefined;
            return { code: magicString.toString(), map: map };
        }
    };
};
